#include<stdio.h>
#include<malloc.h>
#include<stdio.h>
#include<limits.h>
#include<string.h>

#define FALSE 0
#define TRUE 1

#define MAX_CHAR_PER_LINE 1000
#define MAX_NAME 256

void display(linkedlisttype *buffer);
void clear(linkedlisttype *list);
element get_entry(linkedlisttype *list, int pos);
void del(linkedlisttype *list, int pos);
void add_first(linkedlisttype *list, element data);
void add_last(linkedlisttype *list, element data);
void add(linkedlisttype *list, int position, element data);
void remove_node(listnode **phead, listnode *p, listnode *removed);
void insert_node(listnode **phead, listnode *p, listnode *new_node);
void do_command(linkedlisttype *buffer, char command);
void insert_line(linkedlisttype *buffer);
void delete_line(linkedlisttype *buffer);
void write_file(linkedlisttype *buffer);
void read_file(linkedlisttype *buffer);
listnode *get_node_at(linkedlisttype *list, int pos);
int get_length(linkedlisttype *list);
int is_empty(linkedlisttype *list);
void init(linkedlisttype *list);
void warning();
void help();
void error();

typedef struct
{
	char a[MAX_CHAR_PER_LINE];
}element;

typedef struct ListNode
{
	element data;
	struct ListNode *link;
}listnode;

typedef struct LinkedListType
{
	ListNode *head;	//헤드 포인터
	int length;		//노드의 계수
}linkedlisttype;

void error()
{
	printf("메모리 할당 에러\n");
	//exit(1);
}

void help()
{
	printf("*************\n");
	printf("i: 입력\n");
	printf("d: 삭제\n");
	printf("r: 파일일기\n");
	printf("w: 파일쓰기\n");
	printf("q: 종료\n");
	printf("*************\n");
}

void warning()
{
	printf("Warning!\n");
}

void init(linkedlisttype *list)
{
	if (list == NULL) return;
	list->length = 0;
	list->head = NULL;
}

int is_empty(linkedlisttype *list)
{
	if (list->head == NULL) return 1;
	else return 0;
}

int get_length(linkedlisttype *list)
{
	return list->length;
}

//리스트 안에서 pos 위치의 노드를 반환한다.
listnode *get_node_at(linkedlisttype *list, int pos)
{
	int i;
	listnode *tmp_node = list->head;

	if (pos < 0) return NULL;
	for (i = 0; i < pos; i++)
	{
		tmp_node = tmp_node->link;
	}
	return tmp_node;
}

//디스크 파일로부터 데이터를 읽는다.
void read_file(linkedlisttype *buffer)
{
	char fname[MAX_NAME];
	FILE *fd;
	element p;

	if (!is_empty(buffer))
	{
		clear(buffer);
	}
	init(buffer);

	printf("파일 이름: ");
	scanf_s("%s", fname);
	if ((fd = fopen(fname, "r")) == NULL)
	{
		warning();
		return;
	}
	while (fgets(p.a, MAX_CHAR_PER_LINE, fd))
	{
		add_last(buffer, p);
	}
	fclose(fd);
	display(buffer);
}

//버퍼에 있는 데이터를 디스크 파일에 쓴다.
void write_file(linkedlisttype *buffer)
{
	FILE *fd;
	char fname[MAX_NAME];
	element p;
	int i;

	printf("파일 이름: ");
	scanf_s("%s", fname);
	if ((fd = fopen(fname, "w")) == NULL)
	{
		printf("파일을 열수없습니다.\n");
		return;
	}
	for (i = 0; i < get_length(buffer); i++)
	{
		p = get_entry(buffer, i);
		fputs(p.a, fd);
	}
	fclose(fd);
	display(buffer);
}

//하나의 라인을 지운다.
void delete_line(linkedlisttype *buffer)
{
	int position;

	if (is_empty(buffer))
	{
		printf("지울 라인이 없습니다.\n");
	}
	else
	{
		printf("지우고 싶은 라인번호를 입력하세요\n");
		scanf_s("%d", &position);
	}
	display(buffer);
}

//하나의 라인을 삽입한다.
void insert_line(linkedlisttype *buffer)
{
	int position;
	char line[MAX_CHAR_PER_LINE];
	element p;
	
	printf("입력행번호를 입력하세요\n");
	scanf_s("%d", &position);

	printf("내용을 입력하세요: ");
	fflush(stdin);
	fgets(line, MAX_CHAR_PER_LINE, stdin);
	strcpy(p.a, line);
	add(buffer, position, p);
	display(buffer);
}

void do_command(linkedlisttype *buffer, char command)
{
	switch (command)
	{
	case 'd':
		delete_line(buffer);
		break;
	case 'i':
		insert_line(buffer);
		break;
	case 'r':
		read_file(buffer);
		break;
	case 'w':
		write_file(buffer);
		break;
	case 'q':
		break;
	}
}

//phead 리스트의 헤드 포인터의 포인터
//p 선행노드
//new_node 삽입될 노드
void insert_node(listnode **phead, listnode *p, listnode *new_node)
{
	if (*phead == NULL)	//공백 리스트인 경우
	{
		new_node->link = NULL;
		*phead = new_node;
	}
	else if (p == NULL)	//p가 NULL이면 첫 번째 노드로 삽입
	{
		new_node->link = *phead;
		*phead = new_node;
	}
	else
	{
		new_node->link = p->link;
		p->link = new_node;
	}
}

//phead 헤드포인터에 대한 포인터
//p 삭제될 노드의 선행 노드
//removed 삭제될 노드
void remove_node(listnode **phead, listnode *p, listnode *removed)
{
	if (p != NULL)
	{
		*phead = (*phead)->link;
	}
	else
	{
		p->link = removed->link;
	}
	free(removed);
}

//주어진 위치에 데이터를 삽입한다.
void add(linkedlisttype *list, int position, element data)
{
	listnode *p;

	if ((position >= 0) && (position <= list->length))
	{
		listnode *node = (listnode *)malloc(sizeof(listnode));

		if (node == NULL) error();

		node->data = data;
		p = get_node_at(list, position - 1);
		insert_node(&(list->head), p, node);
		list->length++;
	}
}

//리스트의 끝에 데이터를 삽입한다.
void add_last(linkedlisttype *list, element data)
{
	add(list, get_length(list), data);
}

//리스트의 처음에 데이터를 삽입한다.
void add_first(linkedlisttype *list, element data)
{
	add(list, 0, data);
}

//주어진 위치의 데이터를 삭제한다.
void del(linkedlisttype *list, int pos)
{
	if (!is_empty(list) && (pos >= 0) && (pos < list->length))
	{
		listnode *p = get_node_at(list, pos - 1);
		remove_node(&(list->head), p, (p != NULL) ? p->link : NULL);
		list->length--;
	}
}

//주어진 위치에 해당하는 데이터를 반환한다.
element get_entry(linkedlisttype *list, int pos)
{
	listnode * p;
	if (pos >= list->length) error();
	p = get_node_at(list, pos);
	return p->data;
}

//모든 노드를 삭제한다.
void clear(linkedlisttype *list)
{
	int i;

	for (i = 0; i < list->length; i++)
		del(list, i);
}

//버퍼의 내용을 출력한다.
void display(linkedlisttype *buffer)
{
	int i;
	listnode *tmp_node = buffer->head;

	printf("*******************\n");
	for (i = 0; i < buffer->length; i++)
	{
		printf("%d", tmp_node->data.a);
		tmp_node = tmp_node->link;
	}
	printf("*********************\n");
}

//라인 에디터 메인 프로그램
int main(void)
{
	char command;
	linkedlisttype buffer;

	init(&buffer);

	do {
		help();
		command = getchar();
		do_command(&buffer, command);
		fflush(stdin);
	} while (command != 'q');
}
